
Gareth Scott (c) 2011, garethjscott@gmail.com

This project describes a stepper motor controller used by a typical embedded controller.
It allows the motor to accelerate using an S-curve profile described by the equation: 1 / (1 + exp(-t))
The code is written as a C++ class and tested with Cygwin and a Luminary Micro Cortex-M3 controller (LM3S3748).

The architecture of this class adjusts a peripheral timer in the controller to match the acceleration curve.
For speed, a lookup table is used since the timer calls an interrupt service routine and time is at a premium.

There are 3 variables involved in acceleration: max-frequency or omega, time and steps.
The steps to move and frequency (min/max) can be set. The stepper class can tell you
how long the move will take, but will not allow you to set the distance based on time.
That is an easy function to turn on, but we didn't think it very useful.
You can set the time that the acceleration will last but that can be overridden if the
movement is not long enough to contain that acceleration distance.

All times are in micro-seconds unless shown otherwise.

It's hard to draw an s-shaped velocity profile using only ascii-characters.
For a better graph see: http://en.wikipedia.org/wiki/Logistic_function

velocity
|
|         ............... 
|       .                .
|     .                    .
|     .                    .
|   .                        .
|..                            .....  
__________________________________________time

Typical usage shown below:

-------------------------------------------------------------------------------	   

	stepper s;
	s.accelOmega(200, 1200);	// set min/max rotational speed (radians/s) at start and end of acceleration
	s.accelTime(2000000);		// set time to perform acceleration
	s.accelSharpness(8);		// typical smooth s-curve
	s.moveAbsolute(2000);

	s.velocity(200);			// set a continuous velocity
	s.velocity(1200);			// increase velocity using last acceleration curve
	
	s.stop();					// stop by ramping down the acceleration curve

-------------------------------------------------------------------------------	   
	   
Pending tasks (* = addressed this issue):
1. Why does OPTIMIZE_CURVE_CALC produce slightly different results depending on whether it's on and off? Suspect round-off error.
2. This class should do the following:
   a. Move motor from one point to another.
   b. Change velocity
   c. Execute any changes using an acceleration curve
3. Initialize timer code needs added to: stepper_init()
4. Connect isr() up to stepper::isr()
5. Commit to github. Need to consolidate files into one central location. Have FreeRTOS, Luminary and source files for stepper.
6.* Basic regression testing.
7. Debugging output not dependent on #preprocessor macro.
8. Add safeguard to never change motor speed by more than xx Hz.
9. Set position by radians as well as steps
10.* copy constructor and assignment for accel class
11.*Copy stepper and accel classes to motor directory and build them from there...
11a.* ...then submit to Github

12. Follow encoder feature
13. IO port header
14. Queue for motor commands that can't be executed immediately
15. Add RPM setting. Include deg/step
16. Make KiCad project location so new versions can share the same location.
17.* Allow acceleration time to be set in steps rather than us. See: accel::stepsToTime()
18.* Need to get frequency-at-each-step curve correct. Currently it's lopsided in graph. Why?!
     Got it. See motor.ods "Cumulative time from Cygwin motor run" graph.
19. Connect RealTerm
20. Try serial bootloader
21. Consolidate stepper.*, accel.* in one location. Add IAR project to scottdesign
     to keep keep git history of files. Update Makefile since files don't need
     copied any more.
22. Executive commands:
        moveAbsolute(int)     
        position(); // Get current position. To do relative move: moveAbsolute(position() + relative)
        velocity(int); // 
        clearQueue();   //
        disable();
        enable();
        getIO(int); // Read IO line
        setIO(int, int);
23. Change RPM to RPUS (rev-per-microsec). This avoids using floats and keeps the
     timeframe in microsecs.
        
Limitations

Notes
1. Under Cygwin, to redirect output to a file use: ./motor >motor.txt 2>motorErr.txt
2. Note that ./motor is run from a cygwin command window. It needs access to c:\cygwin\bin\cygwin1.dll to run.
    Install a minimal cygwin to get this. To run from a DOS command prompt, add cygwin to your path using the following:
	"set Path=%Path%;c:\cygwin\bin" and then type "motor". It's really best just to install cygwin in the first place.
3. Regression test issue this from the command line: make test1	
